# =====================================
# @Desc: springboot工程配置文件，使用yml方式
# @Auther: andy.ten@tom.com
# @Version: v1.1.1
# =====================================
server:
  tomcat:
    max-connections: 10000
    accept-count: 1000
    threads:
      max: 800
      min-spare: 100

spring:
  #  boot:
  #  admin: # 监控配置 使用注册中心，不需要单独增加client监控
  #  client:
  #    url: http://localhost:8000
  #  instance:
  #    prefer-ip: true
  #  discovery:
  #    ignored-services: consul

  #    main:
  #      allow-bean-definition-overriding: true #后注入的bean是否是覆盖
  servlet: # springboot2.0以后使用servlet，之前使用http
    multipart:
      max-file-size: 5MB # 单个文件大小
      max-request-size: 25MB # 总上传的数据大小
  security:
    user:
      name: admin
      password: admin

  # =====================================
  # 数据源配置
  # =====================================
  datasource: #druid连接池配置，在/druid/index.html可以查看监控页
    type: com.alibaba.druid.pool.DruidDataSource
    druid:
      #driver-class-name: com.mysql.jdbc.Driver
      #com.mysql.jdbc.Driver： 是mybatis-connection-java 5 及 5 以下的
      #com.mysql.cj.jdbc.Driver:对应的是mybatis-connection-Java 6 及以上的,推荐使用
      #com.mysql.cj.jdbc.Driver:需在url后增加指定时区参数：&serverTimezone=Asia/Shanghai
      driver-class-name: com.mysql.cj.jdbc.Driver #UTC:比中国时间早8个小时
      initial-size: 10 #初始化时建立物理连接的个数
      min-idle: 10 #初始化时建立物理连接的个数
      max-active: 20 #最大连接池数量 maxIdle已经不再使用
      max-wait: 60000 #获取连接等待超时的时间，单位毫秒
      time-between-eviction-runs-millis: 60000 #既作为检测的间隔时间又作为testWhileIdel执行的依据，间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒
      min-evictable-idle-time-millis: 300000
      #      max-evictable-idle-time-millis: 900000 #一个连接在池中最大生存的时间，单位是毫秒
      validation-query: select 'x' #用来检测连接是否有效的sql 必须是一个查询语句;mysql中为 select 'x';oracle中为 select 1 from dual
      validation-query-timeout: 5
      test-while-idle: true #申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。
      test-on-borrow: false #申请连接时会执行validationQuery检测连接是否有效,开启会降低性能,默认为true
      test-on-return: false #归还连接时会执行validationQuery检测连接是否有效,开启会降低性能,默认为true
      #      exception-sorter: true #当数据库抛出不可恢复的异常时,抛弃该连接
      pool-prepared-statements: true #是否缓存preparedStatement,mysql5.5+建议开启
      max-pool-prepared-statement-per-connection-size: 20 #当值大于0时poolPreparedStatements会自动修改为true
      use-global-data-source-stat: true #合并多个DruidDataSource的监控数据
      filters: stat,wall,slf4j # 配置监控统计拦截的filters，去掉后监控界面sql无法统计，'wall'用于防火墙，注意filter是有顺序的
      filter:
        stat: # 统计监控信息，配置慢sql
          enabled: true
          log-slow-sql: true
          slow-sql-millis: 3000
          merge-sql: true
        #          db-type: sqlserver
        wall: # 防御SQL注入攻击,配置SQL防火墙
          enabled: true
          config:
            alter-table-allow: false # 是否允许执行Alter Table语句
            truncate-allow: false # truncate语句是危险，缺省打开，若需要自行关闭
            drop-table-allow: false
            none-base-statement-allow: false #是否允许非以上基本语句的其他语句，缺省关闭，通过这个选项就能够屏蔽DDL
            update-where-none-check: true #检查UPDATE语句是否带where条件，这是有风险的，但不是SQL注入类型的风险
            select-into-outfile-allow: false #SELECT ... INTO OUTFILE 是否允许，这个是mysql注入攻击的常见手段，缺省是禁止的
            metadata-allow: true #是否允许调用Connection.getMetadata方法，这个方法调用会暴露数据库的表信息
            multiStatementAllow: true #允许多条sql一起执行
            condition-and-alway-true-allow: true #查询条件被永远是true，允许执行
            comment-allow: true #允许有注释
          log-violation: true #对被认为是攻击的SQL进行LOG.error输出
          throw-exception: true #对被认为是攻击的SQL抛出SQLExcepton
        #          db-type: mysql
        slf4j:
          enabled: true
          connection-log-enabled: false
          connection-close-after-log-enabled: false
          connection-commit-after-log-enabled: false
          connection-rollback-after-log-enabled: false
          connection-connect-after-log-enabled: false
          connection-connect-before-log-enabled: false
          connection-log-error-enabled: false
          data-source-log-enabled: false
          result-set-log-enabled: false
          statement-log-enabled: false
          statement-create-after-log-enabled: false
          statement-executable-sql-log-enable: true
          statement-log-error-enabled: false # 开启后，将打印sql异常的堆栈信息
      stat-view-servlet: #设置访问druid监控页的账号和密码,默认没有
        enabled: true # 是否启用StatViewServlet（监控页面）默认值为false（考虑到安全问题默认并未启动，如需启用建议设置密码或白名单以保障安全）
        login-username: ${DRUID_USER:admin}
        login-password: ${DRUID_PWD:admin123}
        url-pattern: "/druid/*"
        reset-enable: false #允许清除记录
      web-stat-filter: # 用于采集web-jdbc关联监控的数据,监控url访问
        enabled: true
        url-pattern: /* # 添加过滤规则
        exclusions: "*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*" # 排除不需要监控的url，比如.js,/jslib/等等
        profile-enable: true #设置profileEnable能够监控单个url调用的sql列表
        session-stat-max-count: 100000 # 最大session数，缺省是1000个
        session-stat-enable: false # 关闭session统计
      aop-patterns: com.hawthorn.*.service.*
  #      connection-init-sqls: 'set names utf8mb4' # 物理连接初始化的时候执行的sql

  # =====================================
  # consul
  # =====================================
  cloud:
    consul:
      enabled: true
      host: 10.211.55.2
      port: 8500
      discovery:
        enabled: true
        register: true # 是否将自身服务注册到consul中
        hostname: ${server.address}
        health-check-path: /actuator/health  #服务健康检查地址
        health-check-interval: 15s
        health-check-critical-timeout: 30s
        service-name: ${spring.application.name} # 注册到consul的服务名称
        # 默认的id为：${spring.application.name}-${server.port}
        # 默认id配置的问题是：某个微服务即使有多个实例，只要端口相同，那么Consul上依然只会保留1条数据！要想解决这个问题，只需要让不同实例，拥有不同的InstanceId即可。
        instance-id: ${spring.application.name}-${spring.cloud.client.ip-address}-${server.port}

  # =====================================
  # redis
  # =====================================
  redis:
    host: 10.211.55.2
    port: 6379 # Redis服务器连接端口
    password: 123456 # Redis服务器连接密码（默认为空）

    #    cluster: # redis集群
    #      max-redirects: 3 # 获取失败 最大重定向次数，默认值是5 一般当此值设置过大时，容易报：Too many Cluster redirections
    #      nodes: # redis节点
    #        - 10.0.0.1:6380
    #        - 10.0.0.2:6380
    #        - 10.0.0.3:6380
    #        - 10.0.0.1:6381
    #        - 10.0.0.2:6381
    #        - 10.0.0.3:6381

    lettuce: # lettuce:springboot2.0+使用；低版本使用：jedis
      pool:
        max-active: 300 # 连接池最大连接数（使用负值表示没有限制）
        max-wait: -1s # 连接池最大阻塞等待时间（使用负值表示没有限制）
        max-idle: 100 # 连接池中的最大空闲连接
        min-idle: 20 # 连接池中的最小空闲连接
    timeout: 30000 # 连接超时时间（毫秒）如果不设置，取默认值2000
    database: 0 # 连接的数据库

  # =====================================
  # rabbitmq
  # =====================================
  rabbitmq:
    host: 10.211.55.14
    port: 5672
    username: hawthorn-rbmq
    password: 123456
    virtual-host: hawthorn_vhost
    connection-timeout: 3000
    publisher-confirm-type: correlated
    publisher-returns: true
    template:
      retry:
        enabled: true
        max-attempts: 3
        initial-interval: 10000ms
        max-interval: 300000ms
        multiplier: 2
# =====================================
# mybatis plus 配置
# =====================================
mybatis-plus:
  # 如果是放在src/main/java目录下 classpath:/com/yourpackage/*/mapper/*Mapper.xml
  # 如果是放在resource目录 classpath:/mapper/*Mapper.xml
  mapper-locations: classpath*:/mapper/*Mapper.xml
  global-config:
    db-config:
      id-type: AUTO #主键类型  0:"数据库ID自增", 1:"用户输入ID",2:"全局唯一ID (数字类型唯一ID)", 3:"全局唯一ID UUID";
      select-strategy: ignored #是否字段值进行null和'' 比较操作
      insert-strategy: ignored
      update-strategy: ignored
      table-underline: true # 驼峰转换，只对表名有效
      #      table-prefix: mp_ #mp2.3+ 全局表前缀 mp_
      #capital-mode: true #数据库大写下划线转换
      #key-generator: com.baomidou.mybatisplus.incrementer.OracleKeyGenerator # Sequence序列接口实现类配置
      logic-delete-value: 0 #逻辑删除配置 逻辑已删除值,默认为值为1
      logic-not-delete-value: -1 # 逻辑未删除值 0 默认值为0
      #sql-injector: com.baomidou.mybatisplus.mapper.LogicSqlInjector
      #meta-object-handler: com.hawthorn.platform.model.MetaObjectHandleImpl #自定义填充策略接口实现
  configuration:
    map-underscore-to-camel-case: true #配置数据库column列名下划线命名返回为java实体属性的驼峰命名，自动匹配；无需as（没开启这个，SQL需要写as： select user_name as userName）
    cache-enabled: false #关闭二级缓存
    #jdbc-type-for-null: 'null' #配置JdbcTypeForNull, oracle数据库必须配置

  # =====================================
  #JPA配置
  # =====================================
  #  jpa:
  #    database: mysql
  #    properties:
  #      hibernate:
  #        #hibernate.hbm2ddl.auto 参数的作用主要用于：自动创建、更新、验证数据库表结构，有四个值：create、create-drop、update、validate
  #        #create：每次加载 Hibernate 时都会删除上一次生成的表，然后根据 model 类再重新来生成新表，哪怕两次没有任何改变也要这样执行，这就是导致数据库表数据丢失的一个重要原因。
  #        #create-drop：每次加载 Hibernate 时根据 model 类生成表，但是 sessionFactory 一关闭，表就自动删除。
  #        #update：最常用的属性，第一次加载 Hibernate 时根据 model 类会自动建立起表的结构（前提是先建立好数据库），以后加载 Hibernate 时根据 model 类自动更新表结构，即使表结构改变了，但表中的行仍然存在，不会删除以前的行。要注意的是当部署到服务器后，表结构是不会被马上建立起来的，是要等应用第一次运行起来后才会。
  #        #validate ：每次加载 Hibernate 时，验证创建数据库表结构，只会和数据库中的表进行比较，不会创建新表，但是会插入新值。
  #        hbm2ddl:
  #          auto: update
  #        #dialect 主要是指定生成表名的存储引擎为 InnoDB
  #        dialect: org.hibernate.dialect.MySQL5InnoDBDialect
  #        format_sql: true
  #    #show-sql 是否在日志中打印出自动生成的 SQL，方便调试的时候查看
  #    show-sql: true

  # =====================================
  # thymeleaf配置
  # =====================================
#  thymeleaf:
#    cache: false
#    prefix: classpath:/templates/
#    suffix: .html
#    mode: HTML5
#    encoding: UTF-8
#    servlet:
#      content-type: text/html

# 配置feign的Ribbon 不建议配置；httpclient的超时可以在类中配置；重试不建议配置是可能会调用多次导致数据重复
#ribbon:
#  # 当ribbon超时后且hystrix没有超时，就会使用到重试机制
#  # 使用Apache HttpClient连接超时时间，单位为毫秒 因为Ribbon有重试机制，所以Ribb的超时时间是 < Hystrix熔断的超时。
#  ConnectTimeout: 2000
#  # 使用Apache HttpClient读取的超时时间 因为Ribbon有重试机制，所以Ribb的超时时间是 < Hystrix熔断的超时。
#  ReadTimeout: 10000
#  # 最大连接数
#  #MaxTotalConnections: 500
#  # 每个host最大连接数
#  #MaxConnectionsPerHost: 500
#  # 对同一台当前实例的重试次数(请求服务超时6s则会再请求一次)
#  # Ribbon超时重试次数（总的请求次数）：（MaxAutoRetries+1）*（MaxAutoRetriesNextServer+1）
#  # 如果Ribbon没有配置重试时间和次数，默认1S超时，默认重试1次。
#  MaxAutoRetries: 0 # 配置为0表示取消重试
#  # 切换实例的重试次数 如果还失败就切换
#  MaxAutoRetriesNextServer: 1
#  # 对所有操作请求都进行重试；设置为false时，只会对get请求进行重试；对于post、put请求，如果重试，将会导致数据重复执行；
#  okToRetryOnAllOperations: false
#  # 对Http响应码进行重试
#  retryableStatusCodes: 500,401,404,502

# =====================================
# 配置feign
# =====================================
feign:
  httpclient:
    enabled: false # 让feign使用Apache HTTPClient做请求，而不是默认的urlConnection
  okhttp:
    enabled: false # 让feign使用Apache okhttp做请求，而不是默认的urlConnection,okhttp模式不支持压缩配置
  compression: # 压缩配置
    request:
      enabled: true
      mime-types: text/xml,application/xml,application/json # 默认
      min-request-size: 2048 # 默认
    response:
      enabled: true
  hystrix: # 在feign中开启hystrix功能，默认情况下feign不开启hystrix功能
    enabled: true

# =====================================
# 配置hystrix 采用配置类方式实现
# =====================================
#hystrix:
#  threadpool:
#    default:
#      coreSize: 10 # 线程池核心线程数，默认为10；并发执行的最大线程数；大多数时候，默认值为10的线程会很好
#      maxQueueSize: 1000 # 最大排队长度。默认-1，使用SynchronousQueue。其他值则使用 LinkedBlockingQueue。如果要从-1换成其他值则需重启，即该值不能动态调整，若要动态调整，需要使用到下边这个配置
#      queueSizeRejectionThreshold: 800 # 即使maxQueueSize没有达到，达到queueSizeRejectionThreshold该值后，请求也会被拒绝，默认值5
#  command:
#    default: # 全局默认参数，作用的所有的hystrix的客户端,如果需要对某个具体的接口，可以写接口+方法名称
#      enabled: true # 是否开启回退方法
#      execution:
#        isolation:
#          thread:
#            timeoutInMilliseconds: 30000 # 该配置用于 HystrixCommand 执行的超时时间设置，当 HystrixCommand 执行的时间超过了该配置所设置的数值后就会进入服务降级处理，单位是毫秒，默认值为 1000。
#      circuitBreaker:
#        requestVolumeThreshold: 50 # 当在配置时间窗口内达到此数量的失败后，进行短路。默认20个;
#        errorThresholdPercentage: 50% # 出错百分比阈值，当达到此阈值后，开始短路。默认50%）
#        sleepWindowInMilliseconds: 5000 # 短路多久以后开始尝试是否恢复，默认5s）-单位ms
#    TestDemoApi: 单个类配置

# =====================================
# 开放健康检查接口
# =====================================
management:
  endpoints:
    web:
      exposure:
        include: "*"
      # 自定义监控路径 admin
      # 默认值：http://localhost:7001/actuator/*
      # 配置后：http://localhost:7001/admin/*
      #base-path: /admin
  endpoint:
    health:
      show-details: ALWAYS

# =====================================
# swagger
# =====================================
springfox:
  documentation:
    swagger-ui:
      enabled: false
knife4j:
  enable: false

# =====================================
# logback
# =====================================
logging:
  config: classpath:logback-spring-prod.xml
  level:
    #    io.swagger.models.parameters.AbstractSerializableParameter: error
    com.hawthorn: debug
    org.ibatis: debug
    druid.sql: debug
    org.springframework.jdbc: info
    root: info

# =====================================
# 自定义属性
# =====================================
myprops:
  exectime:
    errtime: 5000
    warntime: 3000
